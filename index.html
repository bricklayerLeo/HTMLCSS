<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  <title>前端面试题</title>
  <link href="https://fonts.googleapis.com/css?family=Quicksand:400,700" rel="stylesheet">

<meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
      <link rel="stylesheet" href="css/style.css">
      <style>
    .container{
      display: none;
    }
    .active{
      display: block;
    }
    .answer{
      height: 30px;;
      width: 80px;
      line-height: 30px;
      color: aliceblue;
      background-color: red;
    }
  
      </style>
</head>
<body>
<div style="text-align:center;clear:both;">

</div>
<div class="titlee">
  <p class="answer">HTML&CSS </p>
  <p class="answer">javaScript</p>
  <p class="answer"">vue</p>
  <p class="answer"">http</p>
 
</div>

<div class="container active collapse">
  <details>
    <summary>1、简述一下你对HTML语义化的理解？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p>
        <p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</p>
        <p>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</p>
        <p>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</p>
      </div>
    </div>
  </details>
  <details>
    <summary>2、Doctype作用？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p><!DOCTYPE>声明位于位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器</p>
        <p>的解析器用什么文档标准解析这个文档。</p>
        <p>DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现</p>
      </div>
    </div>
  </details>
  <details>
    <summary>3、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>行内元素有：a b span img input select strong（强调的语气）</p>
        <p>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</p>
        <p>常见的空元素:br hr img input link meta"</p>
      </div>
    </div>
  </details>
  <details>
    <summary>4、页面导入样式时，使用link和@import有什么区别？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>link 是HTML方式， @import 是CSS方式</p>
        <p>link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS</p>
        <p>页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载</p>
      <p>@import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题</p>
      </div>
    </div>
  </details>
  <details>
    <summary>5、常见的浏览器内核有哪些？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</p>
        <p>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</p>
        <p>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]</p>
        <p>Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）]</p>
      </div>
    </div>
  </details>
  <details>
    <summary>6、html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>绘画 canvas ;用于媒介回放的 video 和 audio 元素</p>
        <p>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</p>
        <p>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失
          sessionStorage 的数据在浏览器关闭后自动删除</p>
          <p>语意化更好的内容元素，比如 article、footer、header、nav、section</p>
     <p>新的技术webworker, websocket, Geolocation</p>
        </div>
    </div>
  </details>
  <details>
    <summary>7、Label的作用是什么？是怎么用的？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件</p>
      </div>
    </div>
  </details>
  <details>
    <summary>8、title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响 <br>

          strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b<br>
          
          是展示强调内容<br>
          
          i 内容展示为斜体，em 表示强调的文本<br>
          
          自然样式标签：b, i, u, s, pre<br>
          
          语义样式标签：strong, em, ins, del, code<br>
          
          应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签</p>
 
      </div>
    </div>
  </details>
  <details>
    <summary>9、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>有两种， IE 盒子模型、W3C 盒子模型；</p>
        <p>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</p>
        <p>区 别： IE的content部分把 border 和 padding计算了进去;</p>
      </div>
    </div>
  </details>
  <details>
    <summary>10、CSS选择符有哪些？哪些属性可以继承？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>
          id选择器（ # myid） <br>

类选择器（.myclassname） <br>

标签选择器（div, h1, p） <br>

相邻选择器（h1 + p） <br>

子选择器（ul > li） <br>

后代选择器（li a） <br>

通配符选择器（ * ） <br>

属性选择器（a[rel = “external”]） <br>

伪类选择器（a:hover, li:nth-child） <br>
        </p>
     
      </div>
    </div>
  </details>
  <details>
    <summary>11、CSS优先级算法如何计算？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>优先级为: !important > id > class > tag important 比 内联优先级高</p>
        <p>行内样式 > 内部样式 > 外部样式</p>
        <p>常见的空元素:<br> <hr> <img> <input> <link> <meta></p>
      </div>
    </div>
  </details>
  <details>
    <summary>12、为什么要初始化CSS样式</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的， <br>
          如果没对CSS初始化往往会出现浏览器之间的页面显示差异</p>
  
      </div>
    </div>
  </details>

  <details>
    <summary>13、box-sizing 常用的属性有哪些？分别有什么作用？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>box-sizing: content-box; // 默认的标准(W3C)盒模型元素效果</p>
        <p>box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果</p>
        <p>box-sizing: inherit; // 继承父元素 box-sizing 属性的值</p>
      </div>
    </div>
  </details>
  <details>
    <summary>14、请列举几种隐藏元素的方法</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>

            visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在 <br>

            opacity: 0; CSS3属性，设置0可以使一个元素完全透明<br>
            
            position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外<br>
            
            display: none; 元素会变得不可见，并且不会再占用文档的空间。<br>
            
            transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留<br>
            <br>
            <div hidden="hidden"> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态
            
            height: 0; 将元素高度设为 0 ，并消除边框<br>
            
            filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中<br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>15、rgba() 和 opacity 的透明效果有什么不同？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</p>
        <p>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</p>
       
      </div>
    </div>
  </details>
  <details>
    <summary>16、CSS3有哪些新特性？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>
            新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)} <br>

            弹性盒模型 display: flex; <br>
            
            多列布局 column-count: 5; <br>
            
            媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}} <br>
            
            个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);} <br>
            
            颜色透明度 color: rgba(255, 0, 0, 0.75); <br>
            
            圆角 border-radius: 5px; <br>
            
            渐变 background:linear-gradient(red, green, blue); <br>
            
            阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); <br>
            
            倒影 box-reflect: below 2px; <br>
            
            背景效果 background-size: 100px 100px;
            <br>
            转换 <br>
            
            旋转 transform: rotate(20deg); <br>
            
            倾斜 transform: skew(150deg, -10deg); <br>
            
            位移 transform: translate(20px, 20px); <br>
            
            缩放 transform: scale(.5); <br>
            
            平滑过渡 transition: all .3s ease-in .1s; <br>
            
            动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s; <br>
        </p>
   
      </div>
    </div>
  </details>
  <details>
    <summary>17、请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局</p>
      
      </div>
    </div>
  </details>
  <details>
    <summary>18、li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</summary>
    <div class="details-wrapper">   
      <div class="details-styling">        
        <p>
            li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔 <br>

            解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小 <br>
        </p>
   
      </div>
    </div>
  </details>

  <details>
      <summary>19、什么是外边距重叠？ 重叠的结果是什么？</summary>
      <div class="details-wrapper">   
        <div class="details-styling">        
          <p>
              外边距重叠就是 margin-collapse<br>

相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。<br>
这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距<br>

折叠结果遵循下列计算规则：<br>

两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值<br>

两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值<br>

两个外边距一正一负时，折叠结果是两者的相加的和 
          </p>
     
        </div>
      </div>
    </details>
    <details>
        <summary>20、圣杯布局的实现原理？</summary>
        <div class="details-wrapper">   
          <div class="details-styling">        
            <p>
                要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽<br>
    
                好处：重要的内容放在文档流前面可以优先渲染 <br>
            </p>
       
          </div>
        </div>
      </details>

      <details>
          <summary>21、解释下什么是浮动和它的工作原理？</summary>
          <div class="details-wrapper">   
            <div class="details-styling">        
              <p>
                  非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 <br>
此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。 <br>

工作原理： <br>

浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） <br>

浮动元素碰到包含它的边框或者其他浮动元素的边框停留 <br>
浮动元素引起的问题？<br>

父元素的高度无法被撑开，影响与父元素同级的元素<br>

与浮动元素同级的非浮动元素会跟随其后<br>

列举几种清除浮动的方式？<br>
              </p>
         
            </div>
          </div>
        </details>

        <details>
            <summary>22、CSS优化、提高性能的方法有哪些？</summary>
            <div class="details-wrapper">   
              <div class="details-styling">        
                <p>
                    多个css合并，尽量减少HTTP请求 <br>

                    将css文件放在页面最上面<br>
                    
                    移除空的css规则<br>
                    
                    避免使用CSS表达式<br>
                    
                    选择器优化嵌套，尽量避免层级过深<br>
                    
                    充分利用css继承属性，减少代码量<br>
                    
                    抽象提取公共样式，减少代码量<br>
                    
                    属性值为0时，不加单位<br>
                    
                    属性值为小于1的小数时，省略小数点前面的0<br>
                    
                    css雪碧图<br>
                </p>
           
              </div>
            </div>
          </details>

          <details>
              <summary>23、浏览器是怎样解析CSS选择器的？</summary>
              <div class="details-wrapper">   
                <div class="details-styling">        
                  <p>
                      浏览器解析 CSS 选择器的方式是从右到左
                  </p>
             
                </div>
              </div>
            </details>

            <details>
                <summary>24、在网页中的应该使用奇数还是偶数的字体？</summary>
                <div class="details-wrapper">   
                  <div class="details-styling">        
                    <p>
                        在网页中的应该使用“偶数”字体：<br>

                        偶数字号相对更容易和 web 设计的其他部分构成比例关系<br>
                        
                        使用奇数号字体时文本段落无法对齐<br>
                        
                        宋体的中文网页排布中使用最多的就是 12 和 14<br>
                    </p>
               
                  </div>
                </div>
              </details>

              <details>
                  <summary>25、一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</summary>
                  <div class="details-wrapper">   
                    <div class="details-styling">        
                      <p>
                         1 .sub { height: calc(100%-100px); } <br>

                        2  .container { position:relative; }<br>
.sub { position: absolute; top: 100px; bottom: 0; }<br>

3 .container { display:flex; flex-direction:column; }
         .sub { flex:1; }
                      </p>
                 
                    </div>
                  </div>
                </details>

                <details>
                    <summary>26、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</summary>
                    <div class="details-wrapper">   
                      <div class="details-styling">        
                        <p>
                            响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本 <br>

基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式<br>

对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：<br>
                        </p>
                   
                      </div>
                    </div>
                  </details>

                  <details>
                      <summary>27、你对 line-height 是如何理解的？</summary>
                      <div class="details-wrapper">   
                        <div class="details-styling">        
                          <p>
                              line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离 <br>
                              <br>
                              如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的 <br>
                              
                              一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容 <br>
                              
                              把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中 <br>
                          </p>
                     
                        </div>
                      </div>
                    </details>

                    <details>
                        <summary>28、浏览器是如何渲染页面的？</summary>
                        <div class="details-wrapper">   
                          <div class="details-styling">        
                            <p>
                                渲染的流程如下： <br>

                                1.解析HTML文件，创建DOM树。 
                                
                                自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。 <br>
                                
                                2.解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式； <br>
                                
                                3.将CSS与DOM合并，构建渲染树（Render Tree）
                                <br>
                                4.布局和绘制，重绘（repaint）和重排（reflow） <br>
                            </p>
                       
                          </div>
                        </div>
                      </details>

                      <details>
                          <summary>29、display的属性值都有哪些？</summary>
                          <div class="details-wrapper">   
                            <div class="details-styling">        
                              <p>
                                  none, block, inline, inline-block, table, table-row, table-cell, list-item
                              </p>
                         
                            </div>
                          </div>
                        </details>
                        <details>
                            <summary>30、使用 CSS 预处理的优缺点分别是什么？</summary>
                            <div class="details-wrapper">   
                              <div class="details-styling">        
                                <p>
                                    优点：<br>

                                    提高 CSS 可维护性。<br>
                                    
                                    易于编写嵌套选择器。<br>
                                    
                                    引入变量，增添主题功能。可以在不同的项目中共享主题文件。<br>
                                    
                                    通过混合（Mixins）生成重复的 CSS。<br>
                                    
                                    将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。<br>
                                    
                                    缺点：<br>
                                    
                                    需要预处理工具。<br>
                                    
                                    重新编译的时间可能会很慢。<br>
                                </p>
                           
                              </div>
                            </div>
                          </details>
                          <details>
                              <summary>31、如何解决不同浏览器的样式兼容性问题？</summary>
                              <div class="details-wrapper">   
                                <div class="details-styling">        
                                  <p>
在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。<br>

使用已经处理好此类问题的库，比如 Bootstrap。<br>

使用 autoprefixer 自动生成 CSS 属性前缀。<br>

使用 Reset CSS 或 Normalize.css。<br>
                                  </p>
                             
                                </div>
                              </div>
                            </details>
                            <details>
                                <summary>32、请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？</summary>
                                <div class="details-wrapper">   
                                  <div class="details-styling">        
                                    <p>
  该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。<br>
  在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；<br>

  而 inline 布局则是在水平方向来排列。<br>
  
  弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。<br>
                                    </p>
                               
                                  </div>
                                </div>
                              </details>
                              <details>
                                  <summary>33、box-sizing:border-box;</summary>
                                  <div class="details-wrapper">   
                                    <div class="details-styling">        
                                      <p>
                                          为div设置这个属性之后，这个div的宽度就是内容宽+padding+border的总和。<br>

                                          box-sizing属性用来控制元素的盒子模型的解析模式，默认为content-box<br>
                                          
                                          context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽<br>
                                          
                                          border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽<br>
                                      </p>
                                 
                                    </div>
                                  </div>
                                </details>
                                <details>
                                    <summary>34、CSS 的 transition 和 animation 有何区别？</summary>
                                    <div class="details-wrapper">   
                                      <div class="details-styling">        
                                        <p>
                                            首先 transition 和 animation 都可以做动效，从语义上来理解， transition 是过渡，由 一个状态过渡到另一个状态，比如高度 100px 过渡到 200px ；而 animation 是动画，即更 专业做动效的， animation 有帧的概念，可以设置关键帧 keyframe ，一个动画可以由多个 关键帧多个状态过渡组成，另外 animation 也包含上面提到的多个属性。
                                        </p>
                                   
                                      </div>
                                    </div>
                                  </details>
                                  <details>
                                      <summary> 35、position,文档流的理解</summary>
                                      <div class="details-wrapper">   
                                        <div class="details-styling">        
                                          <p>                                    
                                              1.relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素可通过z-index进行层次分级<br>
                                              
                                              2.fixed 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是 它具有破坏性，会导致其他元素位置的变化。可通过z-index进行层次分级<br>
                                              
                                              3.absolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会 根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元 素，如果找到一个设置了 position:relative/absolute/fixed 的元素，就以该元素为基准 定位，如果没找到，就以浏览器边界定位。可通过z-index进行层次分级    <br>                                        
                                          </p>
                                     
                                        </div>
                                      </div>
                                    </details>
                                    <details>
                                        <summary>36、 阐述一下CSS Sprites</summary>
                                        <div class="details-wrapper">   
                                          <div class="details-styling">        
                                            <p>
                                               

                                                将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。
                                            </p>
                                       
                                          </div>
                                        </div>
                                      </details>
                                      <details>
                                          <summary>37、 清除浮动的几种方式，各自的优缺点</summary>
                                          <div class="details-wrapper">   
                                            <div class="details-styling">        
                                              <p>
                                                 

                                                  父级div定义height <br>
                                        
                                                  
                                                  结尾处加空div标签clear:both <br>
                                                  
                                                  父级div定义伪类:after和zoom <br>
                                                  
                                                  父级div定义overflow:hidden <br>
                                                  
                                                  父级div也浮动，需要定义宽度 <br>
                                                  
                                                  结尾处加br标签clear:both <br>
                                                  
                                                  比较好的是第3种方式，好多网站都这么用 <br>
                                              </p>
                                         
                                            </div>
                                          </div>
                                        </details>
                                        <details>
                                            <summary>38、display:inline-block 什么时候不会显示间隙？(携程)</summary>
                                            <div class="details-wrapper">   
                                              <div class="details-styling">        
                                                <p>
                                                    移除空格 <br>

                                                    使用margin负值<br>

                                                    
                                                    使用font-size:0<br>

                                                    
                                                    letter-spacing<br>

                                                    
                                                    word-spacing<br>

                                                </p>
                                           
                                              </div>
                                            </div>
                                          </details>
                                          <details>
                                              <summary>39、px和em的区别</summary>
                                              <div class="details-wrapper">   
                                                <div class="details-styling">        
                                                  <p>
                                                      

px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 <br>

浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em<br>
                                                  </p>
                                             
                                                </div>
                                              </div>
                                            </details>
                                            <details>
                                                <summary>40、水平居中和垂直居中的方法</summary>
                                                <div class="details-wrapper">   
                                                  <div class="details-styling">        
                                                    <p>
                                                        <strong> 水平居中的方法 </strong><br>

                                                        元素为行内元素，设置父元素text-align:center <br>
                                                        
                                                        如果元素宽度固定，可以设置左右margin为auto;<br>
                                                        
                                                        如果元素为绝对定位，设置父元素position为relative，元素设left:0;right:0;margin:auto;<br>
                                                        
                                                        使用flex-box布局，指定justify-content属性为center<br>
                                                        
                                                        display设置为tabel-ceil<br>
                                                        
                                                        <strong>垂直居中的方法</strong><br>
                                                        
                                                        将显示方式设置为表格，display:table-cell,同时设置vertial-align：middle<br>
                                                        
                                                        使用flex布局，设置为align-item：center<br>
                                                        
                                                        绝对定位中设置bottom:0,top:0,并设置margin:auto <br>
                                                        
                                                        绝对定位中固定高度时设置top:50%，margin-top值为高度一半的负值<br>
                                                        
                                                        文本垂直居中设置line-height为height值<br>
                                                    </p>
                                               
                                                  </div>
                                                </div>
                                              </details>
                                              <details>
                                                  <summary>41、说一说css3的animation</summary>
                                                  <div class="details-wrapper">   
                                                    <div class="details-styling">        
                                                      <p>
                                                          

                                                          css3的animation是css3新增的动画属性，这个css3动画的每一帧是通过@keyframes来声明的，keyframes声明了动画的名称，通过from、to或者是百分比来定义<br>
                                                          
                                                          每一帧动画元素的状态，通过animation-name来引用这个动画，同时css3动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，<br>
                                                          
                                                          这些相关的动画子属性有：animation-name定义动画名、animation-duration定义动画播放的时长、animation-delay定义动画延迟播放的时间、animation-direction定义 动画的播放方向、animation-iteration-count定义播放次数、animation-fill-mode定义动画播放之后的状态、animation-play-state定义播放状态，如暂停运行等、animation-timing-function<br>
                                                          
                                                          定义播放的方式，如恒速播放、艰涩播放等。 <br>
                                                      </p>
                                                 
                                                    </div>
                                                  </div>
                                                </details>
 <details>
     <summary>42、左边宽度固定，右边自适应</summary>
     <div class="details-wrapper">   
       <div class="details-styling">        
         <p>
            方法1：左侧div设置成浮动：float: left，右侧div宽度会自拉升适应 <br>
            方法2：对右侧:div进行绝对定位，然后再设置right=0，即可以实现宽度自适应 <br>
            方法3：将左侧div进行绝对定位，然后右侧div设置margin-left: 200px <br>
            方法4：使用flex布局 
         </p>
    
       </div>
     </div>
   </details>

   <details>
      <summary>43、两种以上方式实现已知或者未知宽度的垂直水平居中</summary>
      <div class="details-wrapper">   
        <div class="details-styling">        
          <p>
              .wraper { <br>

                  position: relative;<br>
                
                  .box {<br>
                
                    position: absolute;<br>
                
                    top: 50%;<br>
                
                    left: 50%;<br>
                
                    width: 100px;<br>
                
                    height: 100px;<br>
                
                    margin: -50px 0 0 -50px;<br>
                
                  }}<br>
                
                /** 2 **/.wraper {<br>
                
                  position: relative;<br>
                
                  .box {<br>
                
                    position: absolute;<br>
                
                    top: 50%;<br>
                
                    left: 50%;<br>
                
                    transform: translate(-50%, -50%);<br>
                
                  }}<br>
                
                /** 3 **/.wraper {<br>
                
                  .box {<br>
                
                    display: flex;<br>
                
                    justify-content:center;<br>
                
                    align-items: center;<br>
                
                    height: 100px;<br>
                
                  }}<br>
                
                /** 4 **/.wraper {<br>
                
                  display: table;<br>
                
                  .box {<br>
                
                    display: table-cell;<br>
                
                    vertical-align: middle;<br>
                
                  }}<br>
          </p>
     
        </div>
      </div>
    </details>
    <details>
        <summary> 44、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</summary>
        <div class="details-wrapper">   
          <div class="details-styling">        
            <p>
   
                

                垂直方向：line-height <br>
                
                水平方向：letter-spacing <br>
                
                
            </p>
       
          </div>
        </div>
      </details>
      <details>
          <summary>45、BFC</summary>
          <div class="details-wrapper">   
            <div class="details-styling">        
              <p>
                  <strong> BFC概念</strong> <br>
                 
                  浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 <br>
                  BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
                 
                  <strong>怎么创建BFC</strong><br>
                  display: table 可能引发响应性问题 <br>
overflow: scroll 可能产生多余的滚动条<br>
float: left 将把元素移至左侧，并被其他元素环绕<br>
4overflow: hidden 将裁切溢出元素(常用)<br>

<strong>BFC可以做什么呢？</strong><br>

利用BFC避免外边距折叠<br>

清除浮动<br>

使用BFC避免文字环绕<br>
              </p>
         
            </div>
          </div>
        </details>
        <details>
            <summary>说一说css3的animation</summary>
            <div class="details-wrapper">   
              <div class="details-styling">        
                <p>
       
                    css3的animation是css3新增的动画属性，这个css3动画的每一帧是通过@keyframes来声明的，keyframes声明了动画的名称，通过from、to或者是百分比来定义<br>
                    
                    每一帧动画元素的状态，通过animation-name来引用这个动画，同时css3动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，<br>
                    
                    这些相关的动画子属性有：animation-name定义动画名、animation-duration定义动画播放的时长、animation-delay定义动画延迟播放的时间、animation-direction定义 动画的播放方向、animation-iteration-count定义播放次数、animation-fill-mode定义动画播放之后的状态、animation-play-state定义播放状态，如暂停运行等、animation-timing-function<br>
                    
                    定义播放的方式，如恒速播放、艰涩播放等。 <br>
                </p>
           
              </div>
            </div>
          </details>
                 

</div>

<div class="container collapse">
  <details>
    <summary>1、JavaScript 由以下三部分组成：</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p>
        <p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</p>
        <p>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</p>
        <p>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、简述一下你对HTML语义化的理解？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          ECMAScript（核心）：JavaScript 语言基础 <br>

DOM（文档对象模型）：规定了访问HTML和XML的接口 <br>

BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法 <br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>2、JS的基本数据类型和引用数据类型，类型判断用哪些方法？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>基本数据类型：undefined、null、boolean、number、string、symbol <br>

          引用数据类型：object、array、function<br>
          
           
          
          类型判断typeof<br>
          
           instanceof 用于实例和构造函数的对应。</p>
      </div>
    </div>
  </details>
  <details>
    <summary>3、介绍JS有哪些内置对象？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          数据封装类对象：Object、Array、Boolean、Number、String <br>

其他对象：Function、Arguments、Math、Date、RegExp、Error<br>

ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect<br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>4、JavaScript作用域？Javascript作用链域?</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>JavaScript作用域：<br>

          在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；<br>
          
          而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。<br>
          Javascript作用链域?
          <br>
          全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节<br>
          
          如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链<br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>5、JavaScript变量声明提升?var、let 及 const 区别？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          JavaScript变量声明提升：

在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。 <br>

声明语句中的赋值部分并不会被提升，只有名称被提升<br>

函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明<br>

如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数<br>

var、let 及 const 区别？<br>

var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用<br>

var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会<br>

let 和 const 作用基本一致，但是后者声明的变量不能再次赋值<br>

var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。<br>

let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>

const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改<br>

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>6、块级作用域 {}</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
       

ES5 中作用域有：全局作用域、函数作用域。没有块作用域的概念。<br>

ES6 中新增了块级作用域。块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域。<br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>7、介绍JavaScript的原型，原型链？有什么特点？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          原型：<br>

JavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型 <br>

JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性<br>

当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。<br>

原型链：<br>

当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找<br>

如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”
<br>
原型特点：<br>

JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变<br>
        </p>
      </div>
    </div>
  </details>

  <details>
    <summary>8、谈谈this对象的理解？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          this 总是指向函数的直接调用者 <br>

如果有 new 关键字，this 指向 new 出来的实例对象<br>

在事件中，this指向触发这个事件的对象<br>

IE下 attachEvent 中的this总是指向全局对象Window<br>
        </p>
      </div>
    </div>
  </details>

  <details>
    <summary>9、eval是做什么的？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          eval的功能是把对应的字符串解析成JS代码并运行 <br>

          应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行） <br>
          
          由JSON字符串转换为JSON对象的时候可以用 eval(’(’+ str +’)’); <br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>10、事件的代理/委托？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件 <br>

          优点： <br>
          
          可以减少事件注册，节省大量内存占用 <br>
          
          可以将事件应用于动态添加的子元素上 <br>
          
          缺点： <br>
          使用不当会造成事件在不应该触发时触发 <br></p>
      </div>
    </div>
  </details>
  <details>
    <summary>11、什么是函数节流？介绍一下应用场景和原理？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>函数节流用于 onresize, onscroll 等短时间内会多次触发的事件 <br>

          函数节流的原理：使用定时器做时间节流。<br>
          当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。<br>
          如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，<br>
          再 setTimeout 一个新的定时器重复以上流程<br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>12、Javascript如何实现继承？javascript创建对象的几种方式？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        Javascript如何实现继承？ <br>

        构造继承 <br>
        
        原型继承 <br>
        
        实例继承 <br>
        
        拷贝继承 <br>
        
        原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 <br>
        
        javascript创建对象的几种方式？ <br>
        
        对象字面量的方式 <br>
        
        用function来模拟无参的构造函数 <br>
        
        用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） <br>
        
        用工厂方式来创建（内置对象） <br>
        
        用原型方式来创建 <br>
        
        用混合方式来创建 <br>
       </p>
      </div>
    </div>
  </details>
  <details>
    <summary>13、null，undefined 的区别？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>null，undefined 的区别？ <br>

          null是一个表示"无"的对象，null 表示一个对象被定义了，值为“空值”，转为数值时为0；undefined 表示不存在这个值，undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined，转为数值时为NaN。
          <br>
          undefined： <br>
          
          　　（1）变量被声明了，但没有赋值时，就等于undefined。 <br>
          
          　　（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 <br>
          
          　　（3）对象没有赋值的属性，该属性的值为undefined。 <br>
          
          　　（4）函数没有返回值时，默认返回undefined。 <br>
          
          null： <br>
          
          　　（1） 作为函数的参数，表示该函数的参数不是对象。 <br>
          
          　　（2） 作为对象原型链的终点。 <br>
          
          （3）在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined <br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>14、说说你对闭包的理解？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>

          使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念
          <br>
          闭包有三个特性：    <br>
          
          1.函数嵌套函数    <br>
          
          2.函数内部可以引用外部的参数和变量    <br>
          
          3.参数和变量不会被垃圾回收机制回收    <br>
         </p>
      </div>
    </div>
  </details>
  <details>
    <summary>15、javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为/p>
      </div>
    </div>
  </details>
  <details>
    <summary>16、js延迟加载的方式有哪些？documen.write和 innerHTML的区别</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          js延迟加载的方式有哪些:<br>

defer和async、动态创建DOM方式（用得最多）、使用setTimeout延迟方法<br>
让JS最后加载<br>
把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度<br>

documen.write和 innerHTML的区别:<br>

document.write只能重绘整个页面<br>

innerHTML可以重绘页面的一部分 <br>

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>17、那些操作会造成内存泄漏？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>

          JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收 <br>
          
          未使用 var 声明的全局变量 <br>
          
          闭包函数(Closures) <br>
          
          循环引用(两个对象相互引用) <br>
          
          控制台日志(console.log) <br>
          
          移除存在绑定事件的DOM元素(IE) <br>
         </p>
      </div>
    </div>
  </details>
  <details>
    <summary>18、判断一个变量是否为数组？ 对象合并（数组合并）?</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          判断一个变量是否为数组: <br>
          Instanceof<br>
          
          isArray<br>
          
          Object.prototype.toString<br>
          
          对象合并（数组合并）:<br>
          
          var obj = Object.assign(a,b)</p>
      </div>
    </div>
  </details>
  <details>
    <summary>19、列举一下JavaScript数组和对象有哪些原生方法？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>

          数组：<br>
          
          arr.concat(arr1, arr2, arrn);<br>
          arr.join(",");<br>
          arr.sort(func);<br>
          arr.pop();<br>
          arr.push(e1, e2, en);<br>
          arr.shift();<br>
          unshift(e1, e2, en);<br>
          arr.reverse();<br>
          arr.slice(start, end);<br>
          arr.splice(index, count, e1, e2, en);<br>
          arr.indexOf(el);<br>
          arr.includes(el); // ES6<br>
          indexOf()和 lastIndexOf() （ES5新增）：indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。<br>
          lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。<br>
          这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。<br>
           
          forEach() （ES5新增）forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。
           <br>
          map() （ES5新增）map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>
           
          filter() （ES5新增）filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。<br>
           
          every() （ES5新增）every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。<br>
           
          some() （ES5新增）some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。<br>
           
          reduce()和 reduceRight() （ES5新增）这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
       
          对象：<br>

          object.hasOwnProperty(prop);<br>
          object.propertyIsEnumerable(prop);<br>
          object.valueOf();<br>
          object.toString();<br>
          object.toLocaleString();<br>
          Class.prototype.isPropertyOf(object);<br>
          Array.splice() 与 Array.splice() 的区别？<br>
          slice – “读取”数组指定的元素，不会对原数组进行修改<br>
          语法：arr.slice(start, end)<br>
          start 指定选取开始位置（含）<br>
          end 指定选取结束位置（不含）v
          splice<br>
          “操作”数组指定的元素，会修改原数组，返回被删除的元素<br>
          语法：arr.splice(index, count, [insert Elements])<br>
          index 是操作的起始位置<br>
          count = 0 插入元素，count > 0 删除元素<br>
          [insert Elements] 向数组新插入的元素<br>
         
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>20、DOM操作——怎样添加、移除、移动、复制、创建和查找节点？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>（1）创建新节点 <br>

          createDocumentFragment() //创建一个DOM片段<br>
          
          createElement() //创建一个具体的元素   createTextNode() //创建一个文本节点<br>
          
          （2）添加、移除、替换、插入<br>
          
          appendChild()    removeChild()    replaceChild()   insertBefore() //在已有的子节点前插入一个新的子节点<br>
          
          （3）查找<br>
          
          getElementsByTagName() //通过标签名称<br>
          
          getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>
          
          getElementById() //通过元素Id，唯一性<br>
         </p>
      </div>
    </div>
  </details>
  <details>
    <summary>21、Ajax 是什么? 如何创建一个Ajax？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>

          1、创建XMLHttpRequest对象 <br>
          
          2，创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br>
          
          3，设置响应HTTP请求状态变化的函数.<br>
          
          4，发送HTTP请求.<br>
          
          5，获取异步调用返回的数据.<br>
          
          6，使用JavaScript和DOM实现局部刷新.<br>
         </p>
      </div>
    </div>
  </details>
  <details>
    <summary>22、JSON 的了解？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。<br>

格式：采用键值对，例如：{'age':'12', 'name':'back'}
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>23、你有哪些性能优化的方法？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 <br>

　　（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 <br>

　　（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 <br>

　　（4） 当需要设置的样式很多时设置className而不是直接操作style。 <br>

　　（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 <br>

　　（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 <br>

（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 <br>

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>24、数组去重es5,es6？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p></p>
      </div>
    </div>
  </details>

  <details>
    <summary>25、深拷贝浅拷贝？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>深拷贝两种方法：JSON.parse(JSON.stringify(obj))，第二种可以使用for...in加递归 <br>

          浅拷贝：引用类型之间进行赋值操作，只是拷贝了引用类型的引用地址而非值，一个改变另一个也改变。</p>
      </div>
    </div>
  </details>
  <details>
    <summary>26、阻止事件冒泡和默认行为？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p> 

          阻止事件冒泡：stopPropagation(),cancelBuble=true;<br>
          
          阻止默认行为：preventDefault,returnValue=false</p>
      </div>
    </div>
  </details>
  <details>
    <summary>27、cookie 和session 的区别？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>

考虑到安全应当使用session。<br>

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>

考虑到减轻服务器性能方面，应当使用COOKIE。<br>

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。v

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>28、描述 cookies、sessionStorage 和 localStorage 的区别？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p> <strong>与服务器交互：</strong> <br>

          cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）<br>
          
          cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递<br>
          
          sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存<br>
          
          <strong>存储大小：</strong> <br>
          
          cookie 数据根据不同浏览器限制，大小一般不能超过 4k<br>
          
          sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
          <br>
          <strong>有期时间：</strong> <br>
          
          localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据<br>
          
          sessionStorage 数据在当前浏览器窗口关闭后自动删除<br>
          
          cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关<br>
         </p>
      </div>
    </div>
  </details>
  <details>
    <summary>29、类的定义和继承的几种方式</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
         <strong> 类的定义:</strong> <br>
          方式一：用构造函数模拟类（传统写法）<br>
          
          方式二：用 class 声明（ES6的写法）<br>

         <strong>继承方式：</strong>  <br>

          方式一：借助构造函数//这种方式，虽然改变了 this 的指向，但是，Child1 无法继承 Parent1 的原型。也就是说，如果我给 Parent1 的原型增加一个方法：这个方法是无法被 Child1 继承的。如下：
          <br>
          方法二：通过原型链实现继承//缺点是：如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变。造成这种缺点的原因是：child1和child2共用原型。
          <br>
          方式三：组合的方式：构造函数 + 原型链//这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。这种方式的缺点是：让父亲Parent的构造方法执行了两次。
          <br>
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>30、 什么是同源策略？</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
         
同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，<br>不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。
<br>
• 不受同源策略限制的：<br>
1、页面中的链接，重定向以及表单提交是不会受到同源策略限制的。<br>
2、跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的"等。

        </p>
      </div>
    </div>
  </details>
 
   

</div>
<div class="container collapse">
  <details>
    <summary>2、 vue路由的钩子函数</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
         

          首页可以控制导航跳转，beforeEach，afterEach等，<br> 
          一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。<br>
          beforeEach主要有3个参数to，from，next：<br>

to：route即将进入的目标路由对象，<br>

from：route当前导航正要离开的路由<br>

next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。
        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>

  <details>
    <summary>1、Vue组件间的参数传递</summary>
    <div class="details-wrapper">
      <div class="details-styling">        
        <p>
          1.父组件与子组件传值 <br>
父组件传给子组件：子组件通过props方法接受数据; <br>
子组件传给父组件：$emit方法传递参数 <br>
2.非父子组件间的数据传递，兄弟组件传值 <br>
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

        </p>
      </div>
    </div>
  </details>
</div>
<div class="container collapse">4</div>

    <script  src="js/index.js"></script>

<script>
var answer = document.getElementsByClassName('answer')
var cont = document.getElementsByClassName('container')
 for(var i=0;i<answer.length;i++){
  answer[i].index=i;
   answer[i].onclick= function(){
    for(var i=0;i<answer.length;i++){
      cont[i].className='container collapse ';
      cont[this.index].className='active container collapse';
    }
   }
 }



</script>


</body>

</html>
